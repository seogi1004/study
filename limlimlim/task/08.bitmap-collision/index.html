<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <style>
        #container canvas{
            position: absolute;
        }
        #land{
            background-color: #ececec;
        }
        #temp{
            display: none;
        }

    </style>
</head>
<body>

<div id="container">
    <canvas id="land" width="700" height="400"></canvas>
    <canvas id="sky" width="700" height="400"></canvas>
    <canvas id="temp" width="700" height="400"></canvas>
</div>


<script src="lib/jquery.js"></script>
<script src="src/vec.js"></script>
<script src="src/vecoper.js"></script>
<script>


    var land = document.getElementById( 'land' );
    var landc = land.getContext( '2d' );
    var sky = document.getElementById( 'sky' );
    var skyc = sky.getContext( '2d' );
    var temp = document.getElementById( 'temp' );
    var tempc = temp.getContext( '2d' );
    var PI2 = 2*Math.PI;

    var Land = {
        init:function(){
            this.vtx = 20;
            this.tempColor = 'blue'
            this.pixelmap = [];
            var x = 0;
            var y = land.height / 1.5;
            var l = land.width / this.vtx;
            var d;
            var h;
            landc.save();
            landc.fillStyle = '#cccccc';
            landc.beginPath();
            landc.moveTo( x, y );
            for( var i=0, count=this.vtx ; i<count ; i+=1 ){
                x+=l;
                h = Math.random() * 20;
                d = Math.round( Math.random() );
                if( d){ y-=h; }
                else{ y+=h; }
                landc.lineTo( x, y );
            }
            landc.lineTo( x, land.height );
            landc.lineTo( 0, land.height );
            landc.closePath();
            landc.fill();
            landc.restore();
            this.updatePixelmap();
        },

        updatePixelmap:function(){
            tempc.drawImage( land, 0, 0 );
            this.pixelmap = tempc.getImageData( 0,0, temp.width, temp.height ).data;
        },

        isCollision:function( bomb ){
            temp.width = temp.width;
            var x = bomb.ltx;
            var y = bomb.lty;
            var targetPixelData = landc.getImageData( x, y, bomb.size*2, bomb.size*2).data;
            for( var i= 0, count=bomb.pixelmap.length ; i<count ; i+=4 ){
                a = bomb.pixelmap[ i+3 ];
                if( a != 0 && targetPixelData[ i+3 ] != 0 && targetPixelData[ i ] != 0 ||  targetPixelData[ i+1 ] != 0 || targetPixelData[ i+2 ] != 0 ){
                    return true;
                }
            }

            return false;
        },

        destroy:function( bomb ){
            landc.save();
            landc.globalCompositeOperation = "destination-out";
            landc.beginPath();
            landc.arc( bomb.x, bomb.y, bomb.power, 0, Math.PI*2, false );
            landc.fill();
            landc.restore();
        }
    };

    var Bomb = function(){
        this.init();
    };

    Bomb.prototype = {
        init:function(){
            this.x = Math.random() * sky.width;
            this.y = Math.random() * -200;
            this.speed = Math.random() + 5;
            this.size = ( Math.random() * 10 ) + 5;
            this.power = this.size*3;
            this.pixelmap = [];
            this.color = '#cccccc';
            this.tempColor = 'red';
            this.updatePixelmap();
        },

        updatePixelmap:function(){
            this.pixelmap = [];
            var size = this.size;
            var size2 = this.size*2;
            temp.width = temp.width;
            tempc.save();
            tempc.fillStyle = this.tempColor;
            tempc.beginPath();
            tempc.arc( size, size, size, 0, PI2, false );
            tempc.fill();
            tempc.restore();
            this.pixelmap = tempc.getImageData(0,0, size2, size2).data;
        },

        update:function(){
            this.y += this.speed;
            this.ltx = this.x-this.size;
            this.lty = this.y-this.size;

            skyc.save();
            skyc.fillStyle = this.color;
            skyc.beginPath();
            skyc.arc( this.x, this.y, this.size, 0, PI2, false );
            skyc.fill();
            skyc.restore();
        },

        exp:function(){
            this.speed = 0;
        }

    };

    var World = {
        loopId:null,
        land:Land,
        bombs:( function(){
            var result = [];
            for( var i= 0, count=10 ; i<count ; i+=1 ){ result.push( new Bomb() ); }
            return result;
        }()),
        init:function(){
            land.width = land.width;
            sky.width = sky.width;
            this.land.init();
        },

        update:function(){
            sky.width = sky.width;
            skyc.save();
            var bomb;
            for( var i= 0, count=this.bombs.length ; i<count ; i+=1 ){
                bomb = this.bombs[ i];
                bomb.update();
                if( this.land.isCollision( bomb ) ){
                    this.land.destroy( bomb );
                    bomb.init();
                }else{
                    console.log( bomb.y+bomb.size/2, land.height );
                    if( bomb.y+bomb.size/2 > land.height ){
                        bomb.init();
                    }
                }
            }
            skyc.restore();
        },

        start:function(){
            var self = this;
            this.stop();
            this.loopId = setInterval( function(){
                self.update();
            }, 1000/40 )
        },

        stop:function(){
            clearInterval( this.loopId );
        }
    };




    World.init();
    World.start();
</script>
</body>
</html>